//
//  ProductsContainerViewController.swift
//  HieCOR
//
//  Created by HyperMacMini on 20/02/18.
//  Copyright Â© 2018 HyperMacMini. All rights reserved.
//

import UIKit
import CoreData

class ProductsContainerViewController: BaseViewController {
    
    //MARK: IBOutlets
    @IBOutlet weak var view_ipadSearch: UIView!
    @IBOutlet weak var ipad_SearchBar: UISearchBar!
    @IBOutlet var collectionView: UICollectionView?
    @IBOutlet weak var ipadsearchView: UIView!
    @IBOutlet weak var manualPaymentButton: UIButton!
    @IBOutlet var searchViewTrailingConstraint: NSLayoutConstraint!
    @IBOutlet var searchViewVerticalSpaceConstraint: NSLayoutConstraint!
    
    //Variables
    var str_SelectedCategoryName = String()
    var selectedIndexSection0: Int?
    var selectedIndexSection1 = Int()
    var arraySected = [String]()
    var array_labelText = [String]()
    var array_SelectStock = Array<Any>()
    var selectedProductCollectionIndex = Int()
    var selectedCollectionIndex = Int()
    var array_Products = [ProductsModel]()
    var array_SearchProducts = [ProductsModel]()
    var isProductSearch : Bool = false
    var isSearchTyping :Bool = false
    var isAPICalled :Bool = false
    var dummyCardNumber = String()
    var delegate: ProductsContainerViewControllerDelegate?
    var catAndProductDelegate: CatAndProductsViewControllerDelegate?
    var editProductDelegate: EditProductsContainerViewDelegate?
    var isCollectionScrolled = false
    var str_noProductPurchase = String()
    var str_showImagesFunctionality = String()
    var str_showProductCodeFunctionality = String()
    var str_showProductPriceFunctionality = String()
    var delegateOne : AttributeUpdateDeleget?
    var cartview = CatAndProductsViewController()
    private var arraySelectedPaymet = [String]()
    var ordertype : OrderType = .newOrder
    
    
    //Private variables
    private var searchFetchOffset:Int = 0
    private var searchFetchLimit:Int = 20
    private var searchPageCount: Int = 1
    private var controller: PopViewController?
    private var pageControl = UIPageControl()
    private var isDataLoading:Bool = false
    private var indexofPage :Int = 1
    private var isLastIndex: Bool = false
    private var refundId = String()
    
    
    //MARK: Class Life Cycle
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.customizeUI()
        self.initializeVariables()
        self.callAPIToGetIngenico()
        self.callAPItoGetCountryList()
        let isSplit = DataManager.selectedPayment?.contains("MULTI CARD")
        if isSplit! {
            print("enterrrrrrrrrrrrrrrrr")
            DataManager.isSplitPayment = true
        } else {
            DataManager.isSplitPayment = false
            print("outerrrrrrrrrrrrrrrrr")
        }
        
        Keyboard._registerForExternalKeyboardChangeNotification()
        
        //SwipeAndSearchVC.shared.initialize()
        //OfflineDataManager Delegate
        if UI_USER_INTERFACE_IDIOM() == .phone {
            OfflineDataManager.shared.productContainerDelegate = self
            //Initialize Swipe Class
            SwipeAndSearchVC.shared.initialize()
        }
        
        
        if appDelegate.str_Refundvalue == "" {
            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                if DataManager.isPromptAddCustomer
                {
                    if DataManager.customerObj == nil || DataManager.customerId == "" {
                        DataManager.isPaymentBtnAddCustomer = false
                        if UI_USER_INTERFACE_IDIOM() == .pad
                        {
                            self.catAndProductDelegate?.hideView?(with: "addcustomerBtn_ActionIPAD")
                        }
                        else
                        {
                            let storyboard = UIStoryboard(name: "Main", bundle: nil)
                            let secondVC = storyboard.instantiateViewController(withIdentifier: "AddNewCutomerViewController") as! AddNewCutomerViewController
                            //secondVC.selectedUser = CustomerObj
                            self.present(secondVC, animated: true, completion: nil)
                            //performSegue(withIdentifier: "selectcustomer", sender: nil)
                        }
                    }
                }
            }
        }
        
        
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
       // SwipeAndSearchVC.delegate = nil
        SwipeAndSearchVC.delegate = self
        ipad_SearchBar.delegate = self
        collectionView?.isPagingEnabled = UI_USER_INTERFACE_IDIOM() == .pad
        if !Keyboard._isExternalKeyboardAttached() {
            UIApplication.shared.keyWindow?.rootViewController?.view.endEditing(true)
        }
        
        SwipeAndSearchVC.shared.isEnable = true
        
        if UI_USER_INTERFACE_IDIOM() == .phone {
            SwipeAndSearchVC.delegate = nil
            SwipeAndSearchVC.delegate = self
            
            if Keyboard._isExternalKeyboardAttached() {
                SwipeAndSearchVC.shared.enableTextField()
            }
        }
     //   ipad_SearchBar.becomeFirstResponder()
    }
    
    override func viewWillLayoutSubviews() {
        super.viewWillLayoutSubviews()
        collectionView?.collectionViewLayout.invalidateLayout()
        self.updatePager()
    }
    
    override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) {
        collectionView?.collectionViewLayout.invalidateLayout()
        super.viewWillTransition(to: size, with: coordinator)
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            self.ipadsearchView.updateCustomBorder()
        }
        controller?.dismiss(animated: true, completion: nil)
    }
    
    //MARK: Private Functions
    private func customizeUI() {
        if(UI_USER_INTERFACE_IDIOM() == .pad)  {
            if let layout = collectionView?.collectionViewLayout as? UICollectionViewFlowLayout {
                layout.scrollDirection = .horizontal
            }
            self.view_ipadSearch.isHidden = false
        } else {
            if let layout = collectionView?.collectionViewLayout as? UICollectionViewFlowLayout {
                layout.scrollDirection = .vertical
            }
            self.view_ipadSearch.isHidden = true
        }
        collectionView?.isPagingEnabled = true
        ipad_SearchBar.keyboardType = .asciiCapable
        ipad_SearchBar.setBorder(borderWidth: 1.0, borderColor: UIColor(red: 240.0/255.0, green: 240.0/255.0, blue: 240.0/255.0, alpha: 1.0), cornerRadius: 4.0)
        if #available(iOS 13.0, *) {
            ipad_SearchBar.searchTextField.backgroundColor = UIColor.white
        }
        self.view.layoutIfNeeded()
    }
    
    private func initializeVariables() {
        self.array_Products = [ProductsModel]()
        self.array_SearchProducts = [ProductsModel]()
        
        self.collectionView?.reloadData()
        isProductSearch = false
        indexofPage = 1
        searchFetchOffset = 0
        searchFetchLimit = 20
        searchPageCount = 1
        ipad_SearchBar.text = ""
        if #available(iOS 13.0, *) {
            ipad_SearchBar.searchTextField.font = UIFont.init(name: "OpenSans", size: 14)
        } else {
            // need to test iOS 12
//           if let textFieldInsideSearchBar = value(forKey: "searchField") as? UITextField {
//                textFieldInsideSearchBar.font = UIFont(name: "OpenSans", size: 14)
//            }
        }
    }
    
    //EditProductAction
    @objc func editProductAction(_ sender: UIButton) {
        
        UIApplication.shared.keyWindow?.rootViewController?.view.endEditing(true)
        selectedCollectionIndex = sender.tag
        
        controller = PopViewController()
        controller = UIStoryboard(name: "Main", bundle: nil).instantiateViewController(withIdentifier: "pop") as? PopViewController
        controller?.modalPresentationStyle = UIModalPresentationStyle.popover
        controller?.preferredContentSize = CGSize(width: 80, height: 40)
        controller?.delegate = self
        
        let popController = controller?.popoverPresentationController
        popController?.permittedArrowDirections = .up
        popController?.backgroundColor = UIColor.white
        popController?.delegate = self
        popController?.sourceRect = CGRect(x: -7, y: 8 , width: 3, height: 3)
        popController?.sourceView = sender
        if let controller = controller {
            self.present(controller, animated: true, completion: {
                controller.view.superview?.layer.cornerRadius = 4
            })
        }
    }
    
    func editButtonClicked(isClicked: Bool) {
        
        self.view.endEditing(true)
        if isClicked
        {
            delegate?.didSelectEditButton?(data: (isProductSearch == false ? self.array_Products[selectedCollectionIndex] : self.array_SearchProducts[selectedCollectionIndex]), index: selectedCollectionIndex, isSearching: isProductSearch)
            if(UI_USER_INTERFACE_IDIOM() == .pad)
            {
                self.editProductDelegate?.didEditProduct?(with: "editproductIPAD")
            }
            else
            {
                self.editProductDelegate?.didSelectProduct?(with: "editproduct")
            }
            
        }
        controller?.dismiss(animated: true, completion: nil)
    }
    
    func updateCollection()
    {
        DispatchQueue.main.async {
            self.collectionView?.reloadData()
            if (self.array_SearchProducts.count>0)
            {
                self.collectionView?.isHidden = false
            }
            else
            {
                self.collectionView?.isHidden = true
            }
            self.updatePager()
        }
    }
    
    //MARK: IBAction Method
    @IBAction func manualPaymentAction(_ sender: Any) {
        if DataManager.isshippingRefundOnly || DataManager.isTipRefundOnly {
            return
        }
        delegate?.didTapOnManualPayment?()
        if Keyboard._isExternalKeyboardAttached() {
            SwipeAndSearchVC.shared.enableTextField()
        }
    }
}

//MARK:- CollectionView Datasource Methods
extension ProductsContainerViewController:  UICollectionViewDataSource {
    public func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int
    {
        return isProductSearch ? array_SearchProducts.count :  array_Products.count
    }
    
    public func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell
    {
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "iPadcell", for: indexPath) as! iPadProductCollectionCell
        
        let array_Products: ProductsModel = isProductSearch ? self.array_SearchProducts[indexPath.row] : self.array_Products[indexPath.row]
        
        if DataManager.isshippingRefundOnly || DataManager.isTipRefundOnly {
            collectionView.isUserInteractionEnabled = false
            cell.alpha = 0.5
            //return
        } else {
            collectionView.isUserInteractionEnabled = true
            cell.alpha = 1
        }
        let price = Double(array_Products.str_price.replacingOccurrences(of: ",", with: "").replacingOccurrences(of: "$", with: "")) ?? 0.0
        cell.productPrice.text = "$" + price.roundToTwoDecimal
        cell.productCode.text = array_Products.str_product_code
        
        if refundId != "" {
            cell.productCode.isHidden = false
            
            cell.productPrice.isHidden = false
        }else{
            if self.str_showProductCodeFunctionality == "true" {
                cell.productCode.isHidden = false
                
            }else{
                cell.productCode.text = ""
                cell.productCode.isHidden = true
            }
            
            if self.str_showProductPriceFunctionality == "true" {
                cell.productPrice.isHidden = false
                
            }else{
                cell.productPrice.isHidden = true
            }
        }
        
        if self.str_showImagesFunctionality == "true" {
            let image = UIImage(named: "category-bg")
            cell.productImage.image = #imageLiteral(resourceName: "m-payment")
            if let url = URL(string: array_Products.str_product_image) {
                cell.productImage.kf.setImage(with: url, placeholder: image, options: nil, progressBlock: nil, completionHandler: nil)
            }else {
                if let data = array_Products.productImageData {
                    cell.productImage.image = UIImage(data: data)
                }
            }
        }else{
            cell.productImage.image = nil
            cell.productImage.image = cell.productImage.image?.withRenderingMode(.alwaysTemplate)
            cell.productImage.tintColor =  #colorLiteral(red: 0.9411764706, green: 0.9411764706, blue: 0.9411764706, alpha: 1)
        }
        
        cell.productTitle.text = array_Products.str_title
        
        cell.editButton.tag = indexPath.row
        
        if let data = UserDefaults.standard.object(forKey: "account_type") as? String {
            if data == "Administrator" && DataManager.isProductEdit {
                
                if ordertype == .newOrder {
                    cell.editButton.isHidden = false
                }else{
                    cell.editButton.isHidden = true
                }
                
            } else {
                cell.editButton.isHidden = true
            }
        } else {
            cell.editButton.isHidden = true
        }
        
        cell.editButton.addTarget(self, action: #selector(editProductAction(_:)), for: .touchUpInside)
        
        
        cell.imgOutOfStock.isHidden = true
        let ob = array_Products.str_stock
        let obj = Double(ob) ?? 0
        
        if (array_Products.isOutOfStock == 1 && self.str_noProductPurchase == "false") {
            cell.imgOutOfStock.isHidden = false
        }
        
        //        if(array_Products.unlimited_stock == "No" && (obj < 1) && self.str_noProductPurchase == "false")
        //        {
        //            cell.imgOutOfStock.isHidden = false
        //        }
        return cell
    }
    
}

//MARK:- CollectionViewLayout Delegate Methods
extension ProductsContainerViewController : UICollectionViewDelegate, UICollectionViewDelegateFlowLayout {
    public func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)
    {
        
        //        self.view.endEditing(true)
        //        UIApplication.shared.keyWindow?.rootViewController?.view.endEditing(true)
        //
        //        let ob = self.array_Products[selectedProductCollectionIndex].str_stock
        //        let obj = Double(ob)
        //
        //        //let cartProductsArray = self.cartProductsArray[indexPath.row]
        //        let isRefundProduct = (ob as AnyObject).value(forKey: "isRefundProduct") as? Bool ?? false
        //
        //        if !isRefundProduct {
        //            if UI_USER_INTERFACE_IDIOM() == .pad {
        //                self.catAndProductDelegate?.didEditProduct?(index: indexPath.row)
        //            }else {
        //                self.editProductDelegate?.didEditProduct?(index: indexPath.row)
        //            }
        //        }
        
        if DataManager.isshippingRefundOnly || DataManager.isTipRefundOnly {
            return
        }
        
        let array_Products: ProductsModel = isProductSearch ? self.array_SearchProducts[indexPath.row] : self.array_Products[indexPath.row]
        
        HomeVM.shared.isAllDataLoaded = [false, false, false]
        selectedProductCollectionIndex = indexPath.row
        let ob = array_Products.str_stock
        let obj = Double(ob) ?? 0
        
        if(UI_USER_INTERFACE_IDIOM() == .pad)
        {
            
            if (array_Products.isOutOfStock == 1 && self.str_noProductPurchase == "false") {
                //showAlert(message: "Out of Stock")
                return
            } else {
                self.view.endEditing(true)
                UIApplication.shared.keyWindow?.rootViewController?.view.endEditing(true)
                self.catAndProductDelegate?.didAddNewProduct?(data: (isProductSearch == false ? self.array_Products[selectedProductCollectionIndex] : self.array_SearchProducts[selectedProductCollectionIndex]), productDetail: (isProductSearch == false ? self.array_Products[selectedProductCollectionIndex].attributesData : self.array_SearchProducts[selectedProductCollectionIndex].attributesData))  //DDDD
                
            }
            //            if(array_Products.unlimited_stock == "No" && (obj < 1) && self.str_noProductPurchase == "false"){
            //                showAlert(message: "Out of Stock")
            //                return
            //            }else{
            //                self.view.endEditing(true)
            //                UIApplication.shared.keyWindow?.rootViewController?.view.endEditing(true)
            //                self.catAndProductDelegate?.didAddNewProduct?(data: (isProductSearch == false ? self.array_Products[selectedProductCollectionIndex] : self.array_SearchProducts[selectedProductCollectionIndex]), productDetail: (isProductSearch == false ? self.array_Products[selectedProductCollectionIndex].attributesData : self.array_SearchProducts[selectedProductCollectionIndex].attributesData))  //DDDD
            //            }
        }
        else
        {
            if (array_Products.isOutOfStock == 1 && self.str_noProductPurchase == "false") {
                //showAlert(message: "Out of Stock")
                return
            } else {
                self.editProductDelegate?.didSelectProduct?(with: "productDetails")
                self.editProductDelegate?.didReceiveProductDetail?(data: (isProductSearch == false ? self.array_Products[selectedProductCollectionIndex] : self.array_SearchProducts[selectedProductCollectionIndex]))
                
            }
            
            //            if(array_Products.unlimited_stock == "No" && (obj < 1)  && self.str_noProductPurchase == "false"){
            //                showAlert(message: "Out of Stock")
            //                return
            //            }else{
            //                self.editProductDelegate?.didSelectProduct?(with: "productDetails")
            //                self.editProductDelegate?.didReceiveProductDetail?(data: (isProductSearch == false ? self.array_Products[selectedProductCollectionIndex] : self.array_SearchProducts[selectedProductCollectionIndex]))
            //            }
        }
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.75) {
            self.controller?.dismiss(animated: true, completion: nil)
        }
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        if(UI_USER_INTERFACE_IDIOM() == .pad) {
            if (UIInterfaceOrientationIsLandscape(UIApplication.shared.statusBarOrientation)) {
                return CGSize(width: CGFloat((collectionView.frame.size.width/4)-15), height: CGFloat((collectionView.frame.size.height / 3)-14))
            }else {
                return CGSize(width: CGFloat((collectionView.frame.size.width/3)-13), height: CGFloat((collectionView.frame.size.width / 4)+14))
            }
        }else {
            return CGSize(width: CGFloat((collectionView.frame.size.width / 3)-5), height: CGFloat((collectionView.frame.size.width / 3)-5))
        }
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets {
        return UIEdgeInsets(top: 5, left:  UI_USER_INTERFACE_IDIOM() == .pad ? 10 : 5, bottom: 5, right: 5)
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -> CGFloat {
        return UI_USER_INTERFACE_IDIOM() == .pad ? 10 : 2
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {
        return UI_USER_INTERFACE_IDIOM() == .pad ? UIInterfaceOrientationIsLandscape(UIApplication.shared.statusBarOrientation) ? 15 : 13 : 2
    }
}

//MARK:- UIScrollViewDelegate Methods
extension ProductsContainerViewController:  UIScrollViewDelegate {
    
    func updatePager() {
        DispatchQueue.main.async {
            var pages = Int()
            
            if UI_USER_INTERFACE_IDIOM() == .pad {
                pages = Int(round(self.collectionView!.contentSize.width / self.collectionView!.frame.size.width))
                self.pageControl.numberOfPages = pages == 0 ? 1 : pages > 5 ? 5 : pages
            }
            
            let width = self.collectionView!.frame.width - (self.collectionView!.contentInset.left*2)
            let index = Int(round(self.collectionView!.contentOffset.x / width)) + 1
            
            let newIndex = index > 5 ? (index <= (pages - 5)) ? (Int(index/5) > 0) ? ((index - ((pages - 5) % 5)) % 5) == 0 ? 5 : ((index - ((pages - 5) % 5)) % 5) : index : (index - (pages - 5)) : index
            
            print(index,newIndex,pages)
            self.pageControl.currentPage = newIndex - 1
            
            self.catAndProductDelegate?.updatePager?(dict: ["numberofpages": self.pageControl.numberOfPages, "pageCount":self.pageControl.currentPage], isCategory: false)
        }
    }
    
    func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {
        isCollectionScrolled = decelerate
    }
    
    func scrollViewDidEndDecelerating(_ scrollView: UIScrollView){
        if isCollectionScrolled {
            isCollectionScrolled = !isCollectionScrolled
            if UI_USER_INTERFACE_IDIOM() == .pad {
                if (self.collectionView!.contentOffset.x + self.collectionView!.frame.width) + 10 >= (self.collectionView!.contentSize.width) {
                    indexofPage = indexofPage + 1
                    searchPageCount = searchPageCount + 1
                    isProductSearch == true ? self.getSearchProductsList() : self.getProductsList()
                }
            }else {
                if (self.collectionView!.contentOffset.y + self.collectionView!.frame.height) + 10 >= (self.collectionView!.contentSize.height) {
                    indexofPage = indexofPage + 1
                    searchPageCount = searchPageCount + 1
                    isProductSearch == true ? self.getSearchProductsList() : self.getProductsList()
                }
            }
        }
        updatePager()
    }
}

extension ProductsContainerViewController: UISearchBarDelegate {
    
    func searchBarShouldBeginEditing(_ searchBar: UISearchBar) -> Bool
    {
        if DataManager.isshippingRefundOnly || DataManager.isTipRefundOnly {
            return false
        }
        ipadsearchView.resetCustomError(isAddAgain: false)
        searchBar.autocorrectionType = .no
        SwipeAndSearchVC.shared.isSearchWithScanner = false
        //Hide Tool Bar
        let shortcut: UITextInputAssistantItem? = searchBar.inputAssistantItem
        shortcut?.leadingBarButtonGroups = []
        shortcut?.trailingBarButtonGroups = []
        
        dummyCardNumber = ""
        Indicator.isEnabledIndicator = false
        searchBar.showsCancelButton = false
        collectionView?.isUserInteractionEnabled = true
        return true
    }
    
    func searchBarShouldEndEditing(_ searchBar: UISearchBar) -> Bool {
        //Handle Swipe Reader Data
        let isSingleBeepSwiper = String(describing: dummyCardNumber.prefix(1)) == ";"
        
        if (String(describing: dummyCardNumber.prefix(2)) != "%B" && !isSingleBeepSwiper) || (String(describing: dummyCardNumber.prefix(1)) != ";" && isSingleBeepSwiper) {
            self.dummyCardNumber = ""
            return true
        }
        
        let cardNumberArray = dummyCardNumber.split(separator: isSingleBeepSwiper ? "=" : "^")
        if isSingleBeepSwiper ? cardNumberArray.count > 1 : cardNumberArray.count > 2 {
            let number = String(describing: String(describing: cardNumberArray.first ?? "").dropFirst(isSingleBeepSwiper ? 1 : 2))
            let month = String(describing: String(describing: String(describing: cardNumberArray[isSingleBeepSwiper ? 1 : 2]).prefix(4)).dropFirst(2))
            let year = String(describing: String(describing: cardNumberArray[isSingleBeepSwiper ? 1 : 2]).prefix(2))
            let name = String(describing: String(describing: cardNumberArray[isSingleBeepSwiper ? 1 : 2]).prefix(2))
            
            SwipeAndSearchVC.shared.cardData = CardData(number: number, year: "20" + year, month: month, name: name)
            self.didGetCardDetail(number: number, month: month, year: "20" + year)
        }else {
            SwipeAndSearchVC.shared.cardData = CardData(number: "", year: "", month: "", name: "")
        }
        self.dummyCardNumber = ""
        return true
    }
    
    func searchBarTextDidEndEditing(_ searchBar: UISearchBar)
    {
        ipadsearchView.resetCustomError(isAddAgain: false)
        Indicator.isEnabledIndicator = true
        //Check For External Accessory
        if Keyboard._isExternalKeyboardAttached() {
            searchBar.resignFirstResponder()
            SwipeAndSearchVC.shared.enableTextField()
        }
        collectionView?.isUserInteractionEnabled = true
        isSearchTyping = false
        
        self.dummyCardNumber = ""
        isProductSearch = !(searchBar.text == "")
        
        if searchBar.text == "" {
            collectionView?.isUserInteractionEnabled = true
            searchPageCount = 1
            searchFetchLimit = 20
            searchFetchOffset = 0
            isProductSearch = false
            self.array_SearchProducts.removeAll()
            if array_Products.count > 0 {
                self.collectionView?.isHidden = false
            }else {
                self.collectionView?.isHidden = true
            }
            self.collectionView?.reloadData()
            searchBar.resignFirstResponder()
        }
        
    }
    
    func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String)
    {
        ipadsearchView.resetCustomError(isAddAgain: false)
        isSearchTyping = true
        searchPageCount = 1
        indexofPage = 1
        isProductSearch = false
        
        searchPageCount = 1
        searchFetchLimit = 20
        searchFetchOffset = 0
        
        collectionView?.isUserInteractionEnabled = true
        
        if searchText.count>0
        {
            isProductSearch = true
            array_SearchProducts.removeAll()
            self.collectionView?.reloadData()
            getSearchProductsList()
        }
        else
        {
            isProductSearch = false
            Indicator.isEnabledIndicator = true
            Indicator.sharedInstance.hideIndicator()
            self.array_SearchProducts.removeAll()
            self.collectionView?.reloadData()
            self.collectionView?.isHidden = false
        }
        self.updatePager()
    }
    
    func searchBarSearchButtonClicked(_ searchBar: UISearchBar)
    {
        searchBar.showsCancelButton = false
        collectionView?.isUserInteractionEnabled = true
        isProductSearch = !(searchBar.text == "")
        
        if Keyboard._isExternalKeyboardAttached() {
            searchBar.resignFirstResponder()
            return
        }
        
        guard ipad_SearchBar.text!.count >= 1 else {
            ipadsearchView.setCustomError(text: "Please enter your search.", bottomSpace: -2.0, bottomLabelSpace: -3, fontSize: 10.0)
            return
        }
        
        searchBar.resignFirstResponder()
    }
    
    func searchBar(_ searchBar: UISearchBar, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
        if text.contains(UIPasteboard.general.string ?? "") && text.containEmoji {
            return false
        }
        
        if range.location == 0 && text == " " {
            return false
        }
        
        dummyCardNumber.append(text)
        if String(describing: dummyCardNumber.prefix(1)) == "%" || String(describing: dummyCardNumber.prefix(2)) == "%B" ||  String(describing: dummyCardNumber.prefix(1)) == ";" {
            if (dummyCardNumber.hasPrefix("%B") &&  dummyCardNumber.hasSuffix("?\n")) || (dummyCardNumber.hasPrefix(";") &&  dummyCardNumber.hasSuffix("?")) {
                searchBar.resignFirstResponder()
            }
            return false
        }
        dummyCardNumber = ""
        
        if text == "\t" {
            return false
        }
        return true
    }
}

//MARK:- PopoverView Delegate Methods
extension ProductsContainerViewController: PopOverEditDelegate {
    override func popoverPresentationControllerDidDismissPopover(_ popoverPresentationController: UIPopoverPresentationController) {
        if Keyboard._isExternalKeyboardAttached() {
            SwipeAndSearchVC.shared.enableTextField()
        }
    }
    
    override func adaptivePresentationStyle(for controller: UIPresentationController, traitCollection: UITraitCollection) -> UIModalPresentationStyle {
        return UIModalPresentationStyle.none
    }
    
    override func popoverPresentationControllerShouldDismissPopover(_ popoverPresentationController: UIPopoverPresentationController) -> Bool
    {
        return true
    }
}

//MARK: API Methods
extension ProductsContainerViewController {
    
    func callAPItoGetCountryList() {
        HomeVM.shared.getCountryList(country: "") { (success, message, error) in
            if success == 1 {
                //...
            }else {
                if !Indicator.isEnabledIndicator {
                    return
                }
                if message != nil {
                    //                    self.showAlert(message: message!)
                    appDelegate.showToast(message: message!)
                }else {
                    self.showErrorMessage(error: error)
                }
            }
        }
    }
    
    func getProductsList(isCheckForAPI: Bool = false) {
        if isCheckForAPI && isAPICalled && UI_USER_INTERFACE_IDIOM() == .phone {
            return
        }
        self.isAPICalled = true
        Indicator.isEnabledIndicator = false
        Indicator.sharedInstance.showIndicator()
        
        let categoryName = str_SelectedCategoryName
        
        let categoryUrl = kGetTotalProducts + "?category=\(categoryName)"
        let refundIdUrl = kGetTotalProducts +  "?refundIds=\(refundId)"
        let refundIdAndCategoryUrl = kGetTotalProducts +  "?refundIds=\(refundId)&category=\(categoryName)"
        
        var searchUrl = String()
        
        if categoryName != "" {
            searchUrl = categoryUrl
        }
        
        if refundId != "" {
            searchUrl = refundIdUrl
        }
        
        if categoryName != "" && refundId != "" {
            searchUrl = refundIdAndCategoryUrl
        }
        
        HomeVM.shared.getProduct(categoryName: searchUrl, pageNumber: indexofPage) { (success, message, error) in
            self.isAPICalled = false
            if success == 1 {
                let objPosApVersion =  DataManager.posAppVersion
                let objiOSVersion =  DataManager.posiOSVersion
                
                
                //Update Data
                self.isLastIndex = !HomeVM.shared.isMoreProductFound
                self.array_Products = HomeVM.shared.productsArray
                self.str_noProductPurchase = DataManager.noInventoryPurchase!
                
                if let val = DataManager.showImagesFunctionality {
                    self.str_showImagesFunctionality = val
                }
                if let productCode = DataManager.showProductCodeFunctionality {
                    self.str_showProductCodeFunctionality = productCode
                }
                if let productPrice = DataManager.showPriceFunctionality {
                    self.str_showProductPriceFunctionality = productPrice
                }
                
                //self.str_showImagesFunctionality = DataManager.showImagesFunctionality!
                
                self.collectionView?.reloadData()
                self.updatePager()
                
                if !HomeVM.shared.isMoreProductFound {
                    self.indexofPage = self.indexofPage - 1
                }else {
                    if UI_USER_INTERFACE_IDIOM() == .pad {
                        DispatchQueue.main.async {
                            let width = self.collectionView!.frame.width - (self.collectionView!.contentInset.left*2)
                            let index = Int(round(self.collectionView!.contentOffset.x / width))
                            self.collectionView?.setContentOffset(CGPoint(x:  CGFloat(index) * (self.collectionView?.bounds.size.width)! , y: 0), animated: true)
                        }
                    }
                }
                
                if (self.array_Products.count>0)
                {
                    self.collectionView?.isHidden = false
                }
                else
                {
                    self.collectionView?.isHidden = true
                }
                
                if HomeVM.shared.productsArray.count > 10 {
                    DispatchQueue.main.asyncAfter(deadline: .now() + 1, execute: {
                        Indicator.isEnabledIndicator = true
                        Indicator.sharedInstance.hideIndicator()
                    })
                } else {
                    Indicator.isEnabledIndicator = true
                    Indicator.sharedInstance.hideIndicator()
                }
                NotificationCenter.default.post(name: NSNotification.Name(rawValue: "notificationName"), object: nil, userInfo: nil)
                self.catAndProductDelegate?.didTapToRefreshHome!()
                if objiOSVersion != objPosApVersion{
                    if DataManager.isShowUpdateNow {
                        if !DataManager.isCheckForAppUpdate{
                            Indicator.isEnabledIndicator = true
                            Indicator.sharedInstance.hideIndicator()
                            DataManager.isCheckForAppUpdate = true
                            let storyboard = UIStoryboard(name: "Main", bundle: nil)
                            let controller = storyboard.instantiateViewController(withIdentifier: "AppVersionViewController") as! AppVersionViewController
                            // self.navigationController?.pushViewController(controller, animated: false)
                            self.navigationController?.present(controller, animated: true, completion: nil)
                        }
                    }
                }
            }else {
                self.indexofPage = self.indexofPage - 1
                if (self.array_Products.count>0)
                {
                    self.collectionView?.isHidden = false
                }
                else
                {
                    self.collectionView?.isHidden = true
                }
                Indicator.isEnabledIndicator = true
                Indicator.sharedInstance.hideIndicator()
                self.updatePager()
                
                if message != nil {
                    //                    self.showAlert(message: message!)
                }else {
                    self.showErrorMessage(error: error)
                }
            }
        }
    }
    
    func getSearchProductsList() {
        let categoryName = str_SelectedCategoryName
        
        let categoryUrl = "&category=\(categoryName)"
        let refundIdUrl = "&refundIds=\(refundId)"
        let refundIdAndCategoryUrl = "&refundIds=\(refundId)&category=\(categoryName)"
        let searchText = ipad_SearchBar.text!
        
        var searchUrl = kGetTotalProducts + "?key=" + searchText
        
        if categoryName != "" {
            searchUrl += categoryUrl
        }
        
        if refundId != "" {
            searchUrl += refundIdUrl
        }
        
        if categoryName != "" && refundId != "" {
            searchUrl += refundIdAndCategoryUrl
        }
        
        DispatchQueue.main.async {
            Indicator.isEnabledIndicator = false
            Indicator.sharedInstance.showIndicator()
        }
        
        SwipeAndSearchVC.shared.isSearchWithScanner = false
        HomeVM.shared.getSearchProduct(searchText: searchUrl, searchFetchLimit: searchFetchLimit, searchPageCount: searchPageCount) { (success, message, error) in
            if success == 1 {
                //Update Data
                DispatchQueue.main.async {
                    self.array_SearchProducts = HomeVM.shared.searchProductsArray
                    self.collectionView?.reloadData()
                    self.collectionView?.isHidden = HomeVM.shared.searchProductsArray.count == 0
                    
                    if HomeVM.shared.searchProductsArray.count == 1 {
                        if(UI_USER_INTERFACE_IDIOM() == .pad)
                        {
                            //self.cartview.delegateUpdate = self
                            self.view.endEditing(true)
                            UIApplication.shared.keyWindow?.rootViewController?.view.endEditing(true)
                            appDelegate.strSearch = self.ipad_SearchBar.text!
                            self.catAndProductDelegate?.didAddNewProduct?(data: HomeVM.shared.searchProductsArray.first!, productDetail: HomeVM.shared.searchProductsArray.first!) //DDDD
                        }
                        else
                        {
                            self.editProductDelegate?.didSelectProduct?(with: "productDetails")
                            self.editProductDelegate?.didReceiveProductDetail?(data: HomeVM.shared.searchProductsArray.first!)
                        }
                        
                        self.searchPageCount = 1
                        self.searchFetchLimit = 20
                        self.searchFetchOffset = 0
                        self.isProductSearch = false
                        self.collectionView?.isHidden = false
                        self.array_SearchProducts.removeAll()
                        self.collectionView?.reloadData()
                        self.ipad_SearchBar.text = ""
                    }
                    self.updatePager()
                    
                    if !HomeVM.shared.isMoreProductFound {
                        self.searchPageCount = self.searchPageCount - 1
                    } else {
                        if UI_USER_INTERFACE_IDIOM() == .pad {
                            DispatchQueue.main.async {
                                let width = self.collectionView!.frame.width - (self.collectionView!.contentInset.left*2)
                                let index = Int(round(self.collectionView!.contentOffset.x / width))
                                self.collectionView?.setContentOffset(CGPoint(x:  CGFloat(index) * (self.collectionView?.bounds.size.width)! , y: 0), animated: true)
                            }
                        }
                    }
                }
                
                if UI_USER_INTERFACE_IDIOM() == .pad {
                    if !Keyboard._isExternalKeyboardAttached() && DataManager.isBarCodeReaderOn {
                        self.ipad_SearchBar.becomeFirstResponder()
                    }
                }
                
                DispatchQueue.main.async {
                    Indicator.isEnabledIndicator = true
                    Indicator.sharedInstance.hideIndicator()
                }
            } else {
                DispatchQueue.main.async {
                    Indicator.isEnabledIndicator = true
                    Indicator.sharedInstance.hideIndicator()
                }
                
                if (self.ipad_SearchBar.text?.isEmpty ?? false) && error == nil {
                    HomeVM.shared.searchProductsArray.removeAll()
                    self.array_SearchProducts.removeAll()
                    self.searchPageCount = 1
                    self.searchFetchLimit = 20
                    self.searchFetchOffset = 0
                    self.isProductSearch = false
                    self.isProductSearch = false
                    self.collectionView?.reloadData()
                    self.collectionView?.isHidden = false
                    self.updatePager()
                    return
                }
                
                self.searchPageCount = self.searchPageCount - 1
                self.array_SearchProducts.removeAll()
                self.collectionView?.reloadData()
                self.collectionView?.isHidden = true
                self.updatePager()
                if message != nil {
                    //...
                } else {
                    self.showErrorMessage(error: error)
                }
            }
        }
    }
    
        func callAPIToGetIngenico() {
            HomeVM.shared.getIngenicoData { (success, message, error) in
                if success == 1 {
                    //...
                }
                else {
                    if !Indicator.isEnabledIndicator {
                        return
                    }
                    if message != nil {
                        if message != "No Coupons Found." {
    //                        self.showAlert(message: message!)
                            appDelegate.showToast(message: message!)
                        }
                    }else {
                        if NetworkConnectivity.isConnectedToInternet() && !DataManager.isOffline{
                            self.showErrorMessage(error: error)
                        }
                    }
                }
            }
        }
    
}

extension ProductsContainerViewController: CategoriesContainerViewControllerDelegate {
    func getProduct(withCategory name: String) {
        self.array_Products = [ProductsModel]()
        self.array_SearchProducts = [ProductsModel]()
        
        ipad_SearchBar.text = ""
        isProductSearch = false
        self.collectionView?.reloadData()
        self.updatePager()
        
        self.str_SelectedCategoryName = name
        indexofPage = 1
        getProductsList()
    }
}

//MARK: ProductsViewControllerDelegate
extension ProductsContainerViewController: ProductsViewControllerDelegate {
    func getProductList() {
        if isProductSearch {
            self.array_SearchProducts = HomeVM.shared.searchProductsArray
        }else {
            self.array_Products = HomeVM.shared.productsArray
            str_noProductPurchase = DataManager.noInventoryPurchase!
            
        }
        
        self.collectionView?.reloadData()
        self.collectionView?.isHidden = false
        self.collectionView?.isUserInteractionEnabled = true
        
        if Keyboard._isExternalKeyboardAttached() {
            SwipeAndSearchVC.shared.enableTextField()
        }
        
    }
}

//MARK: ProductsViewControllerDelegate
extension ProductsContainerViewController: ProductSearchContainerDelegate {
    func didSearchCancel() {
        //....
    }
    
    func didSelectCategory(string: String) {
        self.array_Products.removeAll()
        self.indexofPage = 1
        self.collectionView?.reloadData()
        self.str_SelectedCategoryName = string
        getProductsList()
    }
    
    func didSearchComplete(with product: ProductsModel) {
        if(UI_USER_INTERFACE_IDIOM() == .pad)
        {
            self.view.endEditing(true)
            UIApplication.shared.keyWindow?.rootViewController?.view.endEditing(true)
            self.catAndProductDelegate?.didAddNewProduct?(data: product, productDetail: product)  //DDDD
        }
        else
        {
            self.editProductDelegate?.didSelectProduct?(with: "productDetails")
            self.editProductDelegate?.didReceiveProductDetail?(data: product)
        }
    }
}

//MARK: ResetCartDelegate
extension ProductsContainerViewController: ResetCartDelegate {
    func updateKeyboardStatus(isShow: Bool) {
        if isShow {
            if !iPad_AccessPINViewController.isPresented {
                self.ipad_SearchBar.becomeFirstResponder()
            }
        }else {
            self.ipad_SearchBar.resignFirstResponder()
        }
    }
    
    func resetHomeCart() {
        self.resetCart()
    }
    
    func resetCart() {
        self.refundId = ""
        self.view.endEditing(true)
        isSearchTyping = false
        isProductSearch = false
        ipad_SearchBar.resignFirstResponder()
        self.initializeVariables()
        self.updatePager()
        self.getProductsList()
    }
}

//MARK: SwipeAndSearchDelegate
extension ProductsContainerViewController: SwipeAndSearchDelegate {
    func didReceiveRefundProductIds(string: String) {
        controller?.dismiss(animated: true, completion: nil)
        self.refundId = string
        self.manualPaymentButton.isHidden = string != ""
        searchViewTrailingConstraint.isActive = string != ""
        searchViewVerticalSpaceConstraint.isActive = string == ""
        
        if string != "" {
            self.getProductsList()
        }
    }
    
    func didSearchingProduct() {
        print("Searching")
        controller?.dismiss(animated: true, completion: nil)
    }
    
    func didSearchedProduct(product: ProductsModel) {
        controller?.dismiss(animated: true, completion: nil)
        self.catAndProductDelegate?.hideView?(with: "addcustomerCancelIPAD")
        DispatchQueue.main.async {
            if(UI_USER_INTERFACE_IDIOM() == .pad)
            {
                self.view.endEditing(true)
                UIApplication.shared.keyWindow?.rootViewController?.view.endEditing(true)
                self.catAndProductDelegate?.didAddNewProduct?(data: product, productDetail: product)  //DDDD
            }
            else
            {
                self.editProductDelegate?.didSelectProduct?(with: "productDetails")
                self.editProductDelegate?.didReceiveProductDetail?(data: product)
            }
            
            self.searchPageCount = 1
            self.searchFetchLimit = 20
            self.searchFetchOffset = 0
            self.isProductSearch = false
            self.collectionView?.isHidden = false
            self.array_SearchProducts.removeAll()
            self.collectionView?.reloadData()
            self.ipad_SearchBar.text = ""
        }
        self.updatePager()
    }
    
    func noProductFound() {
        print("no product found")
        controller?.dismiss(animated: true, completion: nil)
        self.catAndProductDelegate?.hideView?(with: "addcustomerCancelIPAD")
        self.collectionView?.isHidden = true
        self.editProductDelegate?.hideDetailView?()
    }
    
    func didEndSearching() {
        controller?.dismiss(animated: true, completion: nil)
        if UI_USER_INTERFACE_IDIOM() == .phone {
            getProductsList(isCheckForAPI: true)
        }
        collectionView?.isUserInteractionEnabled = true
        isProductSearch = false
        
        searchPageCount = 1
        searchFetchLimit = 20
        searchFetchOffset = 0
        ipad_SearchBar.text = ""
        if UI_USER_INTERFACE_IDIOM() == .pad
        {
            if !HomeVM.shared.isAllDataLoaded.contains(false) && DataManager.isBarCodeReaderOn  {
                if !Keyboard._isExternalKeyboardAttached() {
                    if !iPad_AccessPINViewController.isPresented {
                        self.ipad_SearchBar.becomeFirstResponder()
                    }
                }
            }
        }
        
        self.array_SearchProducts.removeAll()
        self.collectionView?.isHidden = false
        self.collectionView?.reloadData()
    }
    
    func didGetCardDetail(number: String, month: String, year: String) {
        controller?.dismiss(animated: true, completion: nil)
        delegate?.didGetCardDetail?()
    }
    
    func noCardDetailFound() {
        controller?.dismiss(animated: true, completion: nil)
        delegate?.noCardDetailFound?()
    }
}

//MARK: OfflineDataManagerDelegate
extension ProductsContainerViewController: OfflineDataManagerDelegate {
    func didUpdateInternetConnection(isOn: Bool) {
        self.delegate?.didUpdateInternet?(isOn: isOn)
        if isOn {
            self.resetCart()
        }else {
            array_SearchProducts.removeAll()
            array_Products.removeAll()
            collectionView?.reloadData()
            self.collectionView?.isHidden = true
            self.catAndProductDelegate?.hideView?(with: "addcustomerCancelIPAD")
            self.editProductDelegate?.hideDetailView?()
        }
    }
}

